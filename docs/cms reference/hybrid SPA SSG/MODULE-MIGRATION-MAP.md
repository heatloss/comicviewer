# Module Migration Map

How existing modules map to the hybrid SSG/SPA architecture.

---

## Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                        REMOVED / REPLACED                           │
│                                                                     │
│   module.Feedparser.js      → Manifest fetch                        │
│   module.Archiveparser.js   → Manifest already has image URLs       │
│   comics.js (static list)   → Generated comics.json                 │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        SIGNIFICANTLY CHANGED                        │
│                                                                     │
│   module.Comicdata.js       → module.Manifest.js (simpler)          │
│   module.Router.js          → Hash-based reader routing             │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        MOSTLY UNCHANGED                             │
│                                                                     │
│   module.Comicreader.js     → Same logic, different data source     │
│   module.Touch.js           → Unchanged                             │
│   module.Zonesystem.js      → Unchanged                             │
│   module.Tabsystem.js       → Unchanged                             │
│   module.Header.js          → Unchanged                             │
│   module.Grid.js            → Data from comics.json instead         │
│   module.Templater.js       → Unchanged (or upgrade to named slots) │
│   module.Storylines.js      → Data from manifest.chapters           │
│   module.Subscriptions.js   → Unchanged (localStorage)              │
│   module.Settings.js        → Unchanged                             │
│   module.Userdata.js        → Unchanged                             │
│   module.Interstitial.js    → Unchanged                             │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Detailed Migration

### REMOVED: module.Feedparser.js

**Current purpose:** Fetches RSS feeds via proxy to get last publication dates.

**In new architecture:** Unnecessary. The manifest includes `publishedDate` for each page and `lastPagePublished` in comic metadata. Build time = publication time.

**Migration:** Delete. Any code that calls `setAllUpdatesFromRSS()` just... doesn't need to anymore.

---

### REMOVED: module.Archiveparser.js

**Current purpose:**
- `getPagesFromArchive()` - Scrapes archive page for chapter/page structure
- `getImageFromPage()` - Scrapes individual page for image URL
- `bufferImageList()` - Preloads images

**In new architecture:**
- Chapter/page structure already in manifest
- Image URLs already in manifest
- Buffering moves to service worker

**Migration:** Delete. Replace with:

```javascript
// Old: scrape for image URL
const imgSrc = await getImageFromPage(pageObj.href);

// New: it's already in the manifest
const imgSrc = pageObj.image;
```

The `bufferImageList` functionality moves to the service worker:

```javascript
// Old: module.Archiveparser.js
const bufferImageList = (imageUrls) => {
  imageUrls.forEach(url => {
    const img = new Image();
    img.src = url;
  });
};

// New: tell service worker to prefetch
const prefetchImages = (imageUrls) => {
  navigator.serviceWorker.controller?.postMessage({
    type: 'PREFETCH_IMAGES',
    urls: imageUrls
  });
};
```

---

### REPLACED: comics.js → comics.json

**Current:** Static JS file with hardcoded comic definitions.

```javascript
// comics.js
export default {
  comics: [
    { name: "XKCD", archiveurl: "...", feedurl: "..." },
    // ...
  ]
};
```

**New:** Generated at build time from CMS.

```json
// comics.json (generated by 11ty)
{
  "comics": [
    {
      "slug": "xkcd",
      "title": "XKCD",
      "coverImage": "/media/xkcd-cover.jpg",
      "description": "A webcomic of romance, sarcasm, math, and language",
      "lastUpdated": "2025-01-02T10:00:00Z",
      "totalPages": 156
    }
  ]
}
```

---

### CHANGED: module.Comicdata.js → module.Manifest.js

**Current purpose:**
- Stores comic data in localStorage
- Fetches/caches scraped data
- Manages progress bars during loading
- Provides `getComic()`, `getPopulatedComic()`, etc.

**New purpose:** Much simpler — just fetch and cache manifests.

```javascript
// module.Manifest.js

const manifestCache = new Map();

const manifest = {
  // Fetch comics index (for grid)
  async getComicsIndex() {
    if (manifestCache.has('index')) {
      return manifestCache.get('index');
    }

    const response = await fetch('/comics.json');
    const data = await response.json();
    manifestCache.set('index', data);
    return data;
  },

  // Fetch single comic manifest
  async getComic(slug) {
    if (manifestCache.has(slug)) {
      return manifestCache.get(slug);
    }

    const response = await fetch(`/comics/${slug}/manifest.json`);
    const data = await response.json();
    manifestCache.set(slug, data);
    return data;
  },

  // Get chapter by number
  getChapter(comicManifest, chapterNum) {
    return comicManifest.chapters.find(ch => ch.number === chapterNum);
  },

  // Get page by number
  getPage(comicManifest, pageNum) {
    return comicManifest.pages.find(p => p.number === pageNum);
  },

  // Get pages for a chapter
  getChapterPages(comicManifest, chapterNum) {
    const chapter = this.getChapter(comicManifest, chapterNum);
    if (!chapter) return [];
    return comicManifest.pages.filter(
      p => p.number >= chapter.startPage && p.number <= chapter.endPage
    );
  },

  // Prefetch upcoming images via service worker
  prefetchAhead(comicManifest, currentPage, count = 5) {
    const urls = [];
    for (let i = 1; i <= count; i++) {
      const page = this.getPage(comicManifest, currentPage + i);
      if (page?.image) urls.push(page.image);
    }

    if (urls.length && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'PREFETCH_IMAGES',
        urls
      });
    }
  }
};

export { manifest };
```

**What's removed:**
- No more `generateProgressbar()` for scraping progress
- No more `sourceAllStorylineCovers()` — covers are in manifest
- No more `sourceSomeImagesInStoryline()` — URLs are in manifest
- No more localStorage for comic data — manifests are cached by SW

---

### CHANGED: module.Router.js

**Current:** Colon-delimited paths (`/comic:title:storyIndex:pageIndex`)

**New:** Could stay the same, or switch to hash routing for reader:

```
/comics/                     → Grid (static HTML or SPA)
/comics/xkcd/                → Comic landing (static HTML)
/comics/xkcd/reader/         → Reader SPA shell
/comics/xkcd/reader/#/5/42   → Reader at chapter 5, page 42
```

**Minimal changes to existing router:**

```javascript
// Keep existing zone routing for non-reader views
const doRoute = {
  '/': gotoIntro,
  '/home': gotoHome,
  '/rack': gotoRack,
  '/comic': gotoComic,  // Now reads from manifest instead of scraping
};

// For reader, parse hash
const parseReaderHash = () => {
  const match = window.location.hash.match(/#\/(\d+)\/(\d+)/);
  if (match) {
    return { chapter: parseInt(match[1]), page: parseInt(match[2]) };
  }
  return null;
};
```

---

### MOSTLY UNCHANGED: module.Comicreader.js

**Current flow:**
1. `initComic(title, storyIndex, pageIndex)`
2. Calls `getPopulatedComic()` which scrapes if needed
3. Gets pages from `comic.storylines[storyIndex].pages`
4. Calls `bufferStorylineImages()` to prefetch
5. Builds ghost mount, handles transitions

**New flow:**
1. `initComic(slug, chapterNum, pageNum)`
2. Calls `manifest.getComic(slug)` — instant if cached
3. Gets pages from `manifest.getChapterPages(comic, chapterNum)`
4. Calls `manifest.prefetchAhead()` — SW handles caching
5. Same ghost mount and transitions

**Key changes:**

```javascript
// Old
import { getPopulatedComic, bufferStorylineImages } from './module.Comicdata.js';

const initComic = async (title, storyNumParam, pageNumParam) => {
  const comic = await getPopulatedComic(title);  // May scrape
  readingState.stack = comic.storylines[storyIndex].pages;
  bufferStorylineImages(readingState.stack, pageIndex);
  // ...
};

// New
import { manifest } from './module.Manifest.js';

const initComic = async (slug, chapterNum, pageNum) => {
  const comic = await manifest.getComic(slug);  // Fetch manifest
  readingState.stack = manifest.getChapterPages(comic, chapterNum);
  manifest.prefetchAhead(comic, pageNum);
  // ...
};
```

The ghost mount logic, transitions, touch handling — all stays the same. You're just changing where the data comes from.

---

### MOSTLY UNCHANGED: module.Grid.js

**Current:** Renders grid from `getAllComics()` which returns hardcoded `comics.js` data.

**New:** Renders grid from `comics.json`.

```javascript
// Old
import { getAllComics } from './module.Comicdata.js';
const comicData = getAllComics();

// New
import { manifest } from './module.Manifest.js';
const comicData = await manifest.getComicsIndex();
```

Grid rendering logic stays identical — just different data source.

---

### MOSTLY UNCHANGED: module.Storylines.js

**Current:** Renders chapter list from `comic.storylines[]`

**New:** Renders chapter list from `manifest.chapters[]`

The data shape is similar enough that this is mostly a rename:

```javascript
// Old
comic.storylines.forEach(storyline => {
  // render storyline.name, storyline.pages.length, etc.
});

// New
manifest.chapters.forEach(chapter => {
  // render chapter.title, chapter.pageCount, etc.
});
```

---

### UNCHANGED: UI Modules

These don't care where data comes from:

- **module.Zonesystem.js** — Zone transitions
- **module.Tabsystem.js** — Tab switching
- **module.Header.js** — Header UI
- **module.Touch.js** — Swipe handling
- **module.Templater.js** — Template rendering
- **module.Interstitial.js** — Between-chapter screens

---

### UNCHANGED: User Data Modules

These stay in localStorage, unaffected by the architecture change:

- **module.Userdata.js** — Reading positions, preferences
- **module.Subscriptions.js** — Followed comics
- **module.Settings.js** — User settings

If you later add reader accounts, these would sync to a server. But that's independent of the manifest architecture.

---

## New Module: Service Worker

**File:** `serviceworker.js` (you already have one, needs expansion)

**Responsibilities:**
- Cache reader shell (HTML, JS, CSS)
- Cache manifests (stale-while-revalidate)
- Cache comic images (cache-first, immutable)
- Handle prefetch requests from reader
- Notify reader of manifest updates

See `SAMPLE-SERVICE-WORKER.js.example` for implementation.

---

## Migration Sequence

1. **Create module.Manifest.js** — New data layer
2. **Update module.Grid.js** — Use manifest for comics list
3. **Update module.Comicreader.js** — Use manifest for pages
4. **Update module.Storylines.js** — Use manifest for chapters
5. **Delete module.Feedparser.js** — No longer needed
6. **Delete module.Archiveparser.js** — No longer needed
7. **Delete comics.js** — Replaced by generated JSON
8. **Update serviceworker.js** — Add caching strategies

Each step can be done independently. The app can work in a hybrid state during migration (some comics from manifest, some from legacy scraping) if needed.

---

## Data Shape Comparison

### Old: comic.storylines[].pages[]

```javascript
{
  name: "XKCD",
  storylines: [
    {
      name: "Chapter 1",
      pages: [
        { href: "https://...", img: { original: "https://..." } },
        { href: "https://...", img: { original: "https://..." } }
      ]
    }
  ]
}
```

### New: manifest.chapters[] + manifest.pages[]

```javascript
{
  comic: { slug: "xkcd", title: "XKCD" },
  chapters: [
    { number: 1, title: "Chapter 1", startPage: 1, endPage: 24 }
  ],
  pages: [
    { number: 1, chapter: 1, image: "/media/...", thumbnail: "/media/..." },
    { number: 2, chapter: 1, image: "/media/...", thumbnail: "/media/..." }
  ]
}
```

The flat `pages[]` array with chapter references is more flexible than nested storylines — easier to navigate by global page number, easier to generate, smaller when serialized.
